<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Voronoi Explorer</title>
  <style>
    :root {
      --bg: #0b0e14;
      --panel: #11151f;
      --muted: #8b9bb4;
      --text: #e6edf3;
      --accent: #6cb6ff;
      --accent-2: #ffb86c;
      --danger: #ff6b6b;
      --ok: #6bff9d;
      --grid: #202634;
    }
    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .app {
      display: grid;
      grid-template-columns: var(--panel-width, 320px) 1fr;
      grid-template-rows: auto 1fr;
      gap: 0;
      height: 100%;
    }
    .app.collapsed { grid-template-columns: 0 1fr; }
    header {
      grid-column: 1 / 3;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 12px 16px;
      border-bottom: 1px solid var(--grid);
      background: linear-gradient(to bottom, rgba(255,255,255,0.02), rgba(0,0,0,0));
    }
    header h1 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      letter-spacing: 0.2px;
    }
    header .meta { color: var(--muted); font-size: 12px; }

    .panel {
      border-right: 1px solid var(--grid);
      background: var(--panel);
      padding: 12px;
      overflow: auto;
    }
    .app.collapsed .panel { padding: 0; border-right: none; overflow: hidden; }

    /* Hamburger */
    .hamburger {
      width: 36px; height: 28px; display: inline-flex; flex-direction: column; justify-content: center; align-items: center;
      gap: 4px; background: transparent; border: 1px solid var(--grid); border-radius: 8px; color: var(--text);
      cursor: pointer; padding: 0;
    }
    .hamburger span { width: 18px; height: 2px; background: var(--text); display: block; border-radius: 2px; }
    .section { margin-bottom: 16px; }
    .section h3 {
      margin: 10px 0 8px;
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      color: var(--muted);
    }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .row + .row { margin-top: 8px; }
    label { font-size: 12px; color: var(--muted); }
    input[type="number"], input[type="range"], select {
      background: #0d1117;
      color: var(--text);
      border: 1px solid var(--grid);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 12px;
      outline: none;
    }
    input[type="range"] { width: 160px; }
    .btn {
      appearance: none;
      border: 1px solid var(--grid);
      background: #0d1117;
      color: var(--text);
      border-radius: 10px;
      font-size: 12px;
      padding: 8px 10px;
      cursor: pointer;
      transition: 120ms ease background, 120ms ease transform, 120ms ease border-color;
    }
    .btn:hover { background: #111827; }
    .btn:active { transform: translateY(1px); }
    .btn.primary { border-color: #245ba7; background: #0e1a2b; color: #cde3ff; }
    .btn.warn { border-color: #7a2b2b; background: #1b0e10; color: #ffd1d1; }
    .btn.ghost { background: transparent; }

    .canvas-wrap { position: relative; height: 100%; }
    canvas { display: block; width: 100%; height: 100%; }
    .hud {
      position: absolute; left: 12px; bottom: 12px; padding: 6px 8px; border-radius: 8px;
      background: rgba(0,0,0,0.35); backdrop-filter: blur(8px);
      font-size: 12px; color: var(--muted); border: 1px solid rgba(255,255,255,0.06);
    }
    .legend { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .chip { display: inline-flex; align-items: center; gap: 6px; }
    .swatch { width: 10px; height: 10px; border-radius: 2px; display: inline-block; }
  </style>
  <script src="https://unpkg.com/d3-delaunay@6.0.4/dist/d3-delaunay.min.js"></script>
</head>
<body>
  <div class="app">
    <header>
      <div style="display:flex; align-items:center; gap:10px;">
        <button id="btn-hamburger" class="hamburger" aria-label="Toggle panel"><span></span><span></span><span></span></button>
        <h1>Voronoi Explorer</h1>
      </div>
      <div class="meta">
        Click to add points • Drag to move • Shift+Click deletes • Cmd/Ctrl+Z undo
      </div>
    </header>
    <aside class="panel">
      <div class="section">
        <h3>Points</h3>
        <div class="row">
          <button id="btn-random" class="btn primary">Add Random</button>
          <input id="num-random" type="number" value="50" min="1" max="5000" step="1" />
          <button id="btn-clear" class="btn warn">Clear</button>
        </div>
        <div class="row">
          <button id="btn-grid" class="btn">Grid</button>
          <button id="btn-hex" class="btn">Hex</button>
        </div>
        <div class="row">
          <button id="btn-undo" class="btn ghost">Undo</button>
          <button id="btn-redo" class="btn ghost">Redo</button>
        </div>
      </div>

      <div class="section">
        <h3>Relaxation</h3>
        <div class="row">
          <button id="btn-relax" class="btn">Lloyd x1</button>
          <label>iters</label>
          <input id="relax-iters" type="number" value="1" min="1" max="50" />
        </div>
        <div class="row">
          <label>Jitter</label>
          <input id="jitter" type="range" min="0" max="10" value="0" />
          <span id="jitter-val" class="meta">0</span>
        </div>
      </div>

      <div class="section">
        <h3>Display</h3>
        <div class="row">
          <label><input id="show-cells" type="checkbox" checked /> Cells</label>
          <label><input id="show-edges" type="checkbox" checked /> Edges</label>
          <label><input id="show-sites" type="checkbox" checked /> Sites</label>
          <label><input id="show-delaunay" type="checkbox" /> Delaunay</label>
        </div>
        <div class="row">
          <label>Cell fill</label>
          <select id="fill-mode">
            <option value="distinct">Distinct (palette)</option>
            <option value="solid">Solid</option>
            <option value="by-index" selected>By Index</option>
            <option value="none">None</option>
          </select>
        </div>
      </div>

      <div class="section">
        <h3>Colors</h3>
        <div class="row">
          <label for="palette-select">Palette</label>
          <select id="palette-select">
            <option value="bright">Bright</option>
            <option value="pastel">Pastel</option>
            <option value="vivid">Vivid</option>
            <option value="warm">Warm</option>
            <option value="cool">Cool</option>
            <option value="solarized">Solarized</option>
          </select>
        </div>
      </div>

      <div class="section">
        <h3>Data</h3>
        <div class="row">
          <button id="btn-export" class="btn">Export JSON</button>
          <label class="btn" for="file-import" style="cursor:pointer;">Import…</label>
          <input id="file-import" type="file" accept="application/json" style="display:none;" />
        </div>
        <div class="row">
          <button id="btn-copy-url" class="btn ghost">Copy Share URL</button>
        </div>
      </div>
    </aside>
    <main class="canvas-wrap">
      <canvas id="canvas"></canvas>
      <div class="hud">
        <div class="legend">
          <span class="chip"><span class="swatch" style="background: var(--accent);"></span>Edge</span>
          <span class="chip"><span class="swatch" style="background: var(--accent-2);"></span>Site</span>
          <span class="chip"><span class="swatch" style="background: var(--ok);"></span>Delaunay</span>
        </div>
      </div>
    </main>
  </div>

  <script>
    // State
    const state = {
      points: [],               // [{x, y}]
      history: [],              // stack of points snapshots
      future: [],               // redo stack
      showCells: true,
      showEdges: true,
      showSites: true,
      showDelaunay: false,
      fillMode: 'by-index',
      jitter: 0,
      paletteName: 'bright',
      siteColorIdx: [],         // stable per-site color indices
    };

    // Canvas & sizing
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    function fitCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const width = Math.floor(rect.width * dpr);
      const height = Math.floor(rect.height * dpr);
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
      }
      const cssWidth = width / dpr;
      const cssHeight = height / dpr;
      return { width, height, dpr, cssWidth, cssHeight };
    }

    // Utilities
    function saveHistory() {
      state.history.push(state.points.map(p => ({ x: p.x, y: p.y })));
      if (state.history.length > 200) state.history.shift();
      state.future.length = 0; // clear redo
    }
    function undo() {
      if (!state.history.length) return;
      state.future.push(state.points.map(p => ({ x: p.x, y: p.y })));
      state.points = state.history.pop();
      draw();
    }
    function redo() {
      if (!state.future.length) return;
      state.history.push(state.points.map(p => ({ x: p.x, y: p.y })));
      state.points = state.future.pop();
      draw();
    }
    function randomPoints(n, width, height) {
      const pts = new Array(n);
      for (let i = 0; i < n; i++) {
        pts[i] = { x: Math.random() * width, y: Math.random() * height };
      }
      return pts;
    }
    function gridPoints(cols, rows, width, height) {
      const pts = [];
      const dx = width / (cols + 1);
      const dy = height / (rows + 1);
      for (let j = 1; j <= rows; j++) {
        for (let i = 1; i <= cols; i++) {
          pts.push({ x: i * dx, y: j * dy });
        }
      }
      return pts;
    }
    function hexPoints(cols, rows, width, height) {
      const pts = [];
      const dx = width / (cols + 1);
      const dy = height / (rows + 1);
      for (let j = 1; j <= rows; j++) {
        for (let i = 1; i <= cols; i++) {
          const offsetX = (j % 2 === 0) ? dx / 2 : 0;
          pts.push({ x: i * dx + offsetX, y: j * dy });
        }
      }
      return pts;
    }
    function jitterPoints(pts, amount) {
      const out = [];
      for (const p of pts) {
        out.push({ x: p.x + (Math.random() - 0.5) * amount, y: p.y + (Math.random() - 0.5) * amount });
      }
      return out;
    }
    
    function centroidOfPolygon(poly) {
      let x = 0, y = 0, a = 0;
      for (let i = 0, n = poly.length, j = n - 1; i < n; j = i++) {
        const p0 = poly[j], p1 = poly[i];
        const f = p0[0] * p1[1] - p1[0] * p0[1];
        x += (p0[0] + p1[0]) * f;
        y += (p0[1] + p1[1]) * f;
        a += f;
      }
      a *= 0.5;
      if (Math.abs(a) < 1e-6) return null;
      return { x: x / (6 * a), y: y / (6 * a) };
    }

    // Voronoi compute & draw
    function compute(cssWidth, cssHeight) {
      if (!state.points.length) return null;
      const delaunay = d3.Delaunay.from(state.points, p => p.x, p => p.y);
      const voronoi = delaunay.voronoi([0, 0, cssWidth, cssHeight]);
      return { delaunay, voronoi };
    }

    // Palettes (10 colors each)
    const palettes = {
      bright: ['#e6194b','#3cb44b','#ffe119','#0082c8','#f58231','#911eb4','#46f0f0','#f032e6','#d2f53c','#fabebe'],
      pastel: ['#ffd1dc','#c1e1c1','#fff5ba','#cce0ff','#ffd8b1','#e6ccff','#d5f6f6','#f6c1ff','#eaffd0','#ffe3e3'],
      vivid:  ['#ff1744','#00e676','#ffea00','#2979ff','#ff9100','#d500f9','#00e5ff','#76ff03','#f50057','#00b0ff'],
      warm:   ['#b71c1c','#e65100','#f9a825','#6d4c41','#d84315','#8d6e63','#c62828','#ff7043','#ff8f00','#795548'],
      cool:   ['#0d47a1','#00897b','#26a69a','#80cbc4','#5c6bc0','#1e88e5','#42a5f5','#90caf9','#00acc1','#4dd0e1'],
      solarized: ['#b58900','#cb4b16','#dc322f','#d33682','#6c71c4','#268bd2','#2aa198','#859900','#657b83','#839496'],
    };

    function hexToRgba(hex, alpha) {
      let h = hex.replace('#','');
      if (h.length === 3) h = h.split('').map(c => c + c).join('');
      const r = parseInt(h.slice(0,2), 16), g = parseInt(h.slice(2,4), 16), b = parseInt(h.slice(4,6), 16);
      const a = Math.max(0, Math.min(1, alpha == null ? 1 : alpha));
      return `rgba(${r}, ${g}, ${b}, ${a})`;
    }

    // DSATUR-style greedy coloring using up to 10 colors
    function computeDistinctColoring(delaunay, numSites, palette) {
      const paletteLen = Math.min(palette.length, 10);
      const adj = new Array(numSites);
      for (let i = 0; i < numSites; i++) adj[i] = new Set();
      for (let i = 0; i < numSites; i++) {
        for (const nb of delaunay.neighbors(i)) { adj[i].add(nb); adj[nb].add(i); }
      }
      // Try to preserve existing colors first
      const seed = (state.siteColorIdx && state.siteColorIdx.length === numSites) ? state.siteColorIdx.slice() : new Array(numSites).fill(-1);
      const colors = dsaturWithSeed(adj, paletteLen, seed);
      // Resolve conflicts minimally if any remain
      resolveConflicts(adj, colors, paletteLen, (typeof draggingIndex === 'number' ? draggingIndex : -1));
      return colors;
    }

    function dsaturWithSeed(adj, paletteLen, seedColors) {
      const n = adj.length;
      const degree = adj.map(s => s.size);
      const colors = new Array(n).fill(-1);
      const neighborColors = new Array(n).fill(0).map(() => new Set());
      const uncolored = new Set(Array.from({ length: n }, (_, i) => i));
      function pickVertex() {
        let best = -1, bestSat = -1, bestDeg = -1;
        for (const v of uncolored) {
          const sat = neighborColors[v].size, deg = degree[v];
          if (sat > bestSat || (sat === bestSat && deg > bestDeg)) { best = v; bestSat = sat; bestDeg = deg; }
        }
        return best;
      }
      while (uncolored.size) {
        const v = pickVertex();
        const used = neighborColors[v];
        let cidx = -1;
        const seed = seedColors[v];
        if (seed != null && seed >= 0 && seed < paletteLen && !used.has(seed)) {
          cidx = seed;
        } else {
          for (let c = 0; c < paletteLen; c++) if (!used.has(c)) { cidx = c; break; }
          if (cidx === -1) cidx = 0;
        }
        colors[v] = cidx; uncolored.delete(v);
        for (const nb of adj[v]) neighborColors[nb].add(cidx);
      }
      return colors;
    }

    function resolveConflicts(adj, colors, paletteLen, preferredIndex) {
      const n = adj.length;
      function hasConflict() {
        for (let u = 0; u < n; u++) for (const v of adj[u]) if (u < v && colors[u] === colors[v]) return [u, v];
        return null;
      }
      function recolorSingle(x) {
        const used = new Set(); for (const nb of adj[x]) used.add(colors[nb]);
        for (let c = 0; c < paletteLen; c++) if (!used.has(c)) { colors[x] = c; return true; }
        return false;
      }
      function kempeSwap(u, v) {
        const cu = colors[u];
        for (let k = 0; k < paletteLen; k++) if (k !== cu) {
          const queue = [u];
          const visited = new Set([u]);
          const inChain = new Set();
          while (queue.length) {
            const x = queue.shift();
            inChain.add(x);
            for (const nb of adj[x]) {
              if (!visited.has(nb) && (colors[nb] === cu || colors[nb] === k)) { visited.add(nb); queue.push(nb); }
            }
          }
          if (!inChain.has(v)) {
            // swap cu <-> k in this component
            for (const x of inChain) colors[x] = (colors[x] === cu ? k : cu);
            return true;
          }
        }
        return false;
      }
      let pair;
      while ((pair = hasConflict())) {
        let [u, v] = pair;
        // Try to resolve with minimal changes
        if (preferredIndex === v) [u, v] = [v, u];
        if (preferredIndex !== -1 && preferredIndex !== u && preferredIndex !== v) {
          // keep preferred stable if possible
        }
        if (recolorSingle(u)) continue;
        if (recolorSingle(v)) continue;
        if (kempeSwap(u, v)) continue;
        // fallback: try recolor any neighbor with least degree
        let bestW = -1, bestDeg = Infinity;
        for (const w of adj[u]) { const d = adj[w].size; if (d < bestDeg) { bestDeg = d; bestW = w; } }
        if (bestW !== -1 && recolorSingle(bestW)) continue;
        // final fallback: expand palette virtually by rotating color of u
        colors[u] = (colors[u] + 1) % paletteLen;
      }
    }

    function draw() {
      const { width, height, dpr, cssWidth, cssHeight } = fitCanvas();
      ctx.save();
      ctx.scale(dpr, dpr);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Background grid
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      ctx.lineWidth = 1;
      for (let x = 0; x < cssWidth; x += 40) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, cssHeight); ctx.stroke();
      }
      for (let y = 0; y < cssHeight; y += 40) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(cssWidth, y); ctx.stroke();
      }

      if (!state.points.length) { ctx.restore(); return; }
      const c = compute(cssWidth, cssHeight);
      if (!c) { ctx.restore(); return; }
      const { delaunay, voronoi } = c;

      // Cells (fills)
      if (state.showCells && state.fillMode !== 'none') {
        let precomputedPalette = null;
        if (state.fillMode === 'distinct') {
          precomputedPalette = palettes[state.paletteName] || palettes.bright;
          if (!precomputedPalette || precomputedPalette.length === 0) precomputedPalette = palettes.bright;
          // Maintain stable colors with minimal changes
          state.siteColorIdx = computeDistinctColoring(delaunay, state.points.length, precomputedPalette);
        }
        for (let i = 0; i < state.points.length; i++) {
          const cell = voronoi.cellPolygon(i);
          if (!cell) continue;
          ctx.beginPath();
          ctx.moveTo(cell[0][0], cell[0][1]);
          for (let k = 1; k < cell.length; k++) ctx.lineTo(cell[k][0], cell[k][1]);
          ctx.closePath();
          if (draggingIndex === i) {
            ctx.fillStyle = 'rgba(0,0,0,1)';
          } else if (state.fillMode === 'solid') {
            ctx.fillStyle = 'rgba(108, 182, 255, 0.10)';
          } else if (state.fillMode === 'by-index') {
            const hue = (i * 47) % 360;
            ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.20)`;
          } else if (state.fillMode === 'distinct') {
            const ci = (state.siteColorIdx[i] != null ? state.siteColorIdx[i] : 0) % precomputedPalette.length;
            ctx.fillStyle = hexToRgba(precomputedPalette[ci], 0.8);
          }
          ctx.fill();
        }
      }

      // Voronoi Edges
      if (state.showEdges) {
        ctx.strokeStyle = 'rgba(108, 182, 255, 0.9)';
        ctx.lineWidth = 1.2;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.beginPath();
        voronoi.render(ctx);
        ctx.stroke();
      }

      // Delaunay
      if (state.showDelaunay) {
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 0.8;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.beginPath();
        delaunay.render(ctx);
        ctx.stroke();
      }

      // Sites
      if (state.showSites) {
        for (let i = 0; i < state.points.length; i++) {
          const p = state.points[i];
          let color = 'rgba(255, 184, 108, 0.95)';
          if (draggingIndex === i) {
            color = 'rgba(255, 153, 0, 0.95)';
          } else if (state.fillMode === 'distinct') {
            const palette = palettes[state.paletteName] || palettes.bright;
            const ci = (state.siteColorIdx[i] != null ? state.siteColorIdx[i] : 0) % palette.length;
            color = hexToRgba(palette[ci], 0.95);
          }
          ctx.fillStyle = color;
          ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI * 2); ctx.fill();
        }
      }

      ctx.restore();
    }

    // Lloyd relaxation
    function lloyd(iterations) {
      const { cssWidth, cssHeight } = fitCanvas();
      for (let it = 0; it < iterations; it++) {
        const c = compute(cssWidth, cssHeight);
        if (!c) return;
        const { voronoi } = c;
        const next = [];
        for (let i = 0; i < state.points.length; i++) {
          const cell = voronoi.cellPolygon(i);
          if (!cell) { next.push(state.points[i]); continue; }
          const centroid = centroidOfPolygon(cell);
          if (!centroid) { next.push(state.points[i]); continue; }
          next.push(centroid);
        }
        state.points = next;
      }
      draw();
    }

    // Interaction
    const pointer = { x: 0, y: 0 };
    let draggingIndex = -1;
    let dragOffset = { x: 0, y: 0 };

    function eventToCanvasPoint(ev) {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      return { x: (ev.clientX - rect.left) * dpr / dpr, y: (ev.clientY - rect.top) * dpr / dpr };
    }
    function findNearestIndex(p, maxDist = 10) {
      let idx = -1, best = maxDist * maxDist;
      for (let i = 0; i < state.points.length; i++) {
        const dx = state.points[i].x - p.x;
        const dy = state.points[i].y - p.y;
        const d2 = dx * dx + dy * dy;
        if (d2 < best) { best = d2; idx = i; }
      }
      return idx;
    }

    canvas.addEventListener('pointerdown', (ev) => {
      const p = eventToCanvasPoint(ev);
      pointer.x = p.x; pointer.y = p.y;
      const hit = findNearestIndex(p, 10);
      if (ev.shiftKey) {
        if (hit !== -1) { saveHistory(); state.points.splice(hit, 1); draw(); }
        return;
      }
      if (hit !== -1) {
        draggingIndex = hit;
        dragOffset.x = state.points[hit].x - p.x;
        dragOffset.y = state.points[hit].y - p.y;
      } else {
        saveHistory();
        state.points.push({ x: p.x, y: p.y });
        draw();
      }
    });
    canvas.addEventListener('pointermove', (ev) => {
      if (draggingIndex === -1) return;
      const p = eventToCanvasPoint(ev);
      state.points[draggingIndex] = { x: p.x + dragOffset.x, y: p.y + dragOffset.y };
      draw();
    });
    canvas.addEventListener('pointerup', () => { draggingIndex = -1; draw(); });
    canvas.addEventListener('pointerleave', () => { draggingIndex = -1; draw(); });

    // Keyboard
    window.addEventListener('keydown', (ev) => {
      if ((ev.metaKey || ev.ctrlKey) && ev.key.toLowerCase() === 'z') {
        ev.shiftKey ? redo() : undo();
      }
    });

    // Controls
    function $(id) { return document.getElementById(id); }
    // Hamburger toggle
    (function setupHamburger(){
      const appEl = document.querySelector('.app');
      const btn = $('btn-hamburger');
      if (btn && appEl) {
        btn.addEventListener('click', () => {
          appEl.classList.toggle('collapsed');
          try { localStorage.setItem('voronoi-panel-collapsed', appEl.classList.contains('collapsed') ? '1' : '0'); } catch {}
          draw();
        });
        try {
          const collapsed = localStorage.getItem('voronoi-panel-collapsed');
          if (collapsed === '1') appEl.classList.add('collapsed');
        } catch {}
      }
    })();
    $('btn-random').addEventListener('click', () => {
      const n = Math.max(1, Math.min(5000, Number($('num-random').value) || 100));
      saveHistory();
      const { cssWidth, cssHeight } = fitCanvas();
      state.points.push(...jitterPoints(randomPoints(n, cssWidth, cssHeight), Number($('jitter').value || 0)));
      draw();
    });
    $('btn-clear').addEventListener('click', () => { saveHistory(); state.points = []; draw(); });
    $('btn-grid').addEventListener('click', () => {
      saveHistory();
      const { cssWidth, cssHeight } = fitCanvas();
      state.points = gridPoints(10, 7, cssWidth, cssHeight);
      draw();
    });
    $('btn-hex').addEventListener('click', () => {
      saveHistory();
      const { cssWidth, cssHeight } = fitCanvas();
      state.points = hexPoints(12, 8, cssWidth, cssHeight);
      draw();
    });
    $('btn-undo').addEventListener('click', undo);
    $('btn-redo').addEventListener('click', redo);

    $('btn-relax').addEventListener('click', () => {
      const it = Math.max(1, Math.min(50, Number($('relax-iters').value) || 1));
      saveHistory();
      lloyd(it);
    });

    $('jitter').addEventListener('input', () => {
      $('jitter-val').textContent = String($('jitter').value);
    });

    $('show-cells').addEventListener('change', (e) => { state.showCells = e.target.checked; draw(); });
    $('show-edges').addEventListener('change', (e) => { state.showEdges = e.target.checked; draw(); });
    $('show-sites').addEventListener('change', (e) => { state.showSites = e.target.checked; draw(); });
    $('show-delaunay').addEventListener('change', (e) => { state.showDelaunay = e.target.checked; draw(); });
    $('fill-mode').addEventListener('change', (e) => { state.fillMode = e.target.value; draw(); });
    const paletteSelect = document.getElementById('palette-select');
    try { paletteSelect.value = (localStorage.getItem('voronoi-palette') || state.paletteName); } catch {}
    state.paletteName = paletteSelect.value;
    paletteSelect.addEventListener('change', () => {
      state.paletteName = paletteSelect.value;
      try { localStorage.setItem('voronoi-palette', state.paletteName); } catch {}
      // If not in distinct mode, switch to it so the change is visible immediately
      const fillModeEl = document.getElementById('fill-mode');
      if (state.fillMode !== 'distinct') {
        state.fillMode = 'distinct';
        if (fillModeEl) fillModeEl.value = 'distinct';
      }
      draw();
    });

    // Export / Import
    $('btn-export').addEventListener('click', () => {
      const data = JSON.stringify({ points: state.points }, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'voronoi-points.json'; a.click();
      URL.revokeObjectURL(url);
    });
    $('file-import').addEventListener('change', (ev) => {
      const file = ev.target.files && ev.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const obj = JSON.parse(String(reader.result || '{}'));
          if (Array.isArray(obj.points)) {
            saveHistory();
            state.points = obj.points.map(p => ({ x: Number(p.x), y: Number(p.y) })).filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));
            draw();
          }
        } catch (e) { console.error(e); }
      };
      reader.readAsText(file);
      ev.target.value = '';
    });
    $('btn-copy-url').addEventListener('click', async () => {
      const params = new URLSearchParams();
      params.set('pts', btoa(unescape(encodeURIComponent(JSON.stringify(state.points)))));
      const share = location.origin + location.pathname + '?' + params.toString();
      try { await navigator.clipboard.writeText(share); } catch {}
    });

    // Load from URL
    (function loadFromURL() {
      const sp = new URLSearchParams(location.search);
      const enc = sp.get('pts');
      if (!enc) return;
      try {
        const json = decodeURIComponent(escape(atob(enc)));
        const arr = JSON.parse(json);
        if (Array.isArray(arr)) state.points = arr;
      } catch {}
    })();

    // Resize
    const resizeObserver = new ResizeObserver(() => draw());
    resizeObserver.observe(document.querySelector('.canvas-wrap'));
    window.addEventListener('orientationchange', draw);

    // Initial seed
    (function seed() {
      if (state.points.length) { draw(); return; }
      const { cssWidth, cssHeight } = fitCanvas();
      state.points = randomPoints(50, cssWidth, cssHeight);
      draw();
    })();
  </script>
</body>
</html>


