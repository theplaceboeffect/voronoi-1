<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Voronoi Explorer</title>
  <style>
    :root {
      --bg: #0b0e14;
      --panel: #11151f;
      --muted: #8b9bb4;
      --text: #e6edf3;
      --accent: #6cb6ff;
      --accent-2: #ffb86c;
      --danger: #ff6b6b;
      --ok: #6bff9d;
      --grid: #202634;
    }
    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .app {
      display: grid;
      grid-template-columns: 320px 1fr;
      grid-template-rows: auto 1fr;
      gap: 0;
      height: 100%;
    }
    header {
      grid-column: 1 / 3;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid var(--grid);
      background: linear-gradient(to bottom, rgba(255,255,255,0.02), rgba(0,0,0,0));
    }
    header h1 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      letter-spacing: 0.2px;
    }
    header .meta { color: var(--muted); font-size: 12px; }

    .panel {
      border-right: 1px solid var(--grid);
      background: var(--panel);
      padding: 12px;
      overflow: auto;
    }
    .section { margin-bottom: 16px; }
    .section h3 {
      margin: 10px 0 8px;
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      color: var(--muted);
    }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .row + .row { margin-top: 8px; }
    label { font-size: 12px; color: var(--muted); }
    input[type="number"], input[type="range"], select {
      background: #0d1117;
      color: var(--text);
      border: 1px solid var(--grid);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 12px;
      outline: none;
    }
    input[type="range"] { width: 160px; }
    .btn {
      appearance: none;
      border: 1px solid var(--grid);
      background: #0d1117;
      color: var(--text);
      border-radius: 10px;
      font-size: 12px;
      padding: 8px 10px;
      cursor: pointer;
      transition: 120ms ease background, 120ms ease transform, 120ms ease border-color;
    }
    .btn:hover { background: #111827; }
    .btn:active { transform: translateY(1px); }
    .btn.primary { border-color: #245ba7; background: #0e1a2b; color: #cde3ff; }
    .btn.warn { border-color: #7a2b2b; background: #1b0e10; color: #ffd1d1; }
    .btn.ghost { background: transparent; }

    .canvas-wrap { position: relative; height: 100%; }
    canvas { display: block; width: 100%; height: 100%; }
    .hud {
      position: absolute; left: 12px; bottom: 12px; padding: 6px 8px; border-radius: 8px;
      background: rgba(0,0,0,0.35); backdrop-filter: blur(8px);
      font-size: 12px; color: var(--muted); border: 1px solid rgba(255,255,255,0.06);
    }
    .legend { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .chip { display: inline-flex; align-items: center; gap: 6px; }
    .swatch { width: 10px; height: 10px; border-radius: 2px; display: inline-block; }
  </style>
  <script src="https://unpkg.com/d3-delaunay@6.0.4/dist/d3-delaunay.min.js"></script>
</head>
<body>
  <div class="app">
    <header>
      <h1>Voronoi Explorer</h1>
      <div class="meta">
        Click to add points • Drag to move • Shift+Click deletes • Cmd/Ctrl+Z undo
      </div>
    </header>
    <aside class="panel">
      <div class="section">
        <h3>Points</h3>
        <div class="row">
          <button id="btn-random" class="btn primary">Add Random</button>
          <input id="num-random" type="number" value="50" min="1" max="5000" step="1" />
          <button id="btn-clear" class="btn warn">Clear</button>
        </div>
        <div class="row">
          <button id="btn-grid" class="btn">Grid</button>
          <button id="btn-hex" class="btn">Hex</button>
        </div>
        <div class="row">
          <button id="btn-undo" class="btn ghost">Undo</button>
          <button id="btn-redo" class="btn ghost">Redo</button>
        </div>
      </div>

      <div class="section">
        <h3>Relaxation</h3>
        <div class="row">
          <button id="btn-relax" class="btn">Lloyd x1</button>
          <label>iters</label>
          <input id="relax-iters" type="number" value="1" min="1" max="50" />
        </div>
        <div class="row">
          <label>Jitter</label>
          <input id="jitter" type="range" min="0" max="10" value="0" />
          <span id="jitter-val" class="meta">0</span>
        </div>
      </div>

      <div class="section">
        <h3>Display</h3>
        <div class="row">
          <label><input id="show-cells" type="checkbox" checked /> Cells</label>
          <label><input id="show-edges" type="checkbox" checked /> Edges</label>
          <label><input id="show-sites" type="checkbox" checked /> Sites</label>
          <label><input id="show-delaunay" type="checkbox" /> Delaunay</label>
        </div>
        <div class="row">
          <label>Cell fill</label>
          <select id="fill-mode">
            <option value="none">None</option>
            <option value="solid">Solid</option>
            <option value="by-index" selected>By Index</option>
          </select>
        </div>
      </div>

      <div class="section">
        <h3>Data</h3>
        <div class="row">
          <button id="btn-export" class="btn">Export JSON</button>
          <label class="btn" for="file-import" style="cursor:pointer;">Import…</label>
          <input id="file-import" type="file" accept="application/json" style="display:none;" />
        </div>
        <div class="row">
          <button id="btn-copy-url" class="btn ghost">Copy Share URL</button>
        </div>
      </div>
    </aside>
    <main class="canvas-wrap">
      <canvas id="canvas"></canvas>
      <div class="hud">
        <div class="legend">
          <span class="chip"><span class="swatch" style="background: var(--accent);"></span>Edge</span>
          <span class="chip"><span class="swatch" style="background: var(--accent-2);"></span>Site</span>
          <span class="chip"><span class="swatch" style="background: var(--ok);"></span>Delaunay</span>
        </div>
      </div>
    </main>
  </div>

  <script>
    // State
    const state = {
      points: [],               // [{x, y}]
      history: [],              // stack of points snapshots
      future: [],               // redo stack
      showCells: true,
      showEdges: true,
      showSites: true,
      showDelaunay: false,
      fillMode: 'by-index',
      jitter: 0,
    };

    // Canvas & sizing
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    function fitCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const width = Math.floor(rect.width * dpr);
      const height = Math.floor(rect.height * dpr);
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
      }
      const cssWidth = width / dpr;
      const cssHeight = height / dpr;
      return { width, height, dpr, cssWidth, cssHeight };
    }

    // Utilities
    function saveHistory() {
      state.history.push(state.points.map(p => ({ x: p.x, y: p.y })));
      if (state.history.length > 200) state.history.shift();
      state.future.length = 0; // clear redo
    }
    function undo() {
      if (!state.history.length) return;
      state.future.push(state.points.map(p => ({ x: p.x, y: p.y })));
      state.points = state.history.pop();
      draw();
    }
    function redo() {
      if (!state.future.length) return;
      state.history.push(state.points.map(p => ({ x: p.x, y: p.y })));
      state.points = state.future.pop();
      draw();
    }
    function randomPoints(n, width, height) {
      const pts = new Array(n);
      for (let i = 0; i < n; i++) {
        pts[i] = { x: Math.random() * width, y: Math.random() * height };
      }
      return pts;
    }
    function gridPoints(cols, rows, width, height) {
      const pts = [];
      const dx = width / (cols + 1);
      const dy = height / (rows + 1);
      for (let j = 1; j <= rows; j++) {
        for (let i = 1; i <= cols; i++) {
          pts.push({ x: i * dx, y: j * dy });
        }
      }
      return pts;
    }
    function hexPoints(cols, rows, width, height) {
      const pts = [];
      const dx = width / (cols + 1);
      const dy = height / (rows + 1);
      for (let j = 1; j <= rows; j++) {
        for (let i = 1; i <= cols; i++) {
          const offsetX = (j % 2 === 0) ? dx / 2 : 0;
          pts.push({ x: i * dx + offsetX, y: j * dy });
        }
      }
      return pts;
    }
    function jitterPoints(pts, amount) {
      const out = [];
      for (const p of pts) {
        out.push({ x: p.x + (Math.random() - 0.5) * amount, y: p.y + (Math.random() - 0.5) * amount });
      }
      return out;
    }
    
    function centroidOfPolygon(poly) {
      let x = 0, y = 0, a = 0;
      for (let i = 0, n = poly.length, j = n - 1; i < n; j = i++) {
        const p0 = poly[j], p1 = poly[i];
        const f = p0[0] * p1[1] - p1[0] * p0[1];
        x += (p0[0] + p1[0]) * f;
        y += (p0[1] + p1[1]) * f;
        a += f;
      }
      a *= 0.5;
      if (Math.abs(a) < 1e-6) return null;
      return { x: x / (6 * a), y: y / (6 * a) };
    }

    // Voronoi compute & draw
    function compute(cssWidth, cssHeight) {
      if (!state.points.length) return null;
      const delaunay = d3.Delaunay.from(state.points, p => p.x, p => p.y);
      const voronoi = delaunay.voronoi([0, 0, cssWidth, cssHeight]);
      return { delaunay, voronoi };
    }

    function draw() {
      const { width, height, dpr, cssWidth, cssHeight } = fitCanvas();
      ctx.save();
      ctx.scale(dpr, dpr);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Background grid
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      ctx.lineWidth = 1;
      for (let x = 0; x < cssWidth; x += 40) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, cssHeight); ctx.stroke();
      }
      for (let y = 0; y < cssHeight; y += 40) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(cssWidth, y); ctx.stroke();
      }

      if (!state.points.length) { ctx.restore(); return; }
      const c = compute(cssWidth, cssHeight);
      if (!c) { ctx.restore(); return; }
      const { delaunay, voronoi } = c;

      // Cells (fills)
      if (state.showCells && state.fillMode !== 'none') {
        for (let i = 0; i < state.points.length; i++) {
          const cell = voronoi.cellPolygon(i);
          if (!cell) continue;
          ctx.beginPath();
          ctx.moveTo(cell[0][0], cell[0][1]);
          for (let k = 1; k < cell.length; k++) ctx.lineTo(cell[k][0], cell[k][1]);
          ctx.closePath();
          if (state.fillMode === 'solid') {
            ctx.fillStyle = 'rgba(108, 182, 255, 0.10)';
          } else if (state.fillMode === 'by-index') {
            const hue = (i * 47) % 360;
            ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.20)`;
          }
          ctx.fill();
        }
      }

      // Voronoi Edges
      if (state.showEdges) {
        ctx.strokeStyle = 'rgba(108, 182, 255, 0.9)';
        ctx.lineWidth = 1.2;
        voronoi.render(ctx);
      }

      // Delaunay
      if (state.showDelaunay) {
        ctx.strokeStyle = 'rgba(107, 255, 157, 0.7)';
        ctx.lineWidth = 0.8;
        delaunay.render(ctx);
      }

      // Sites
      if (state.showSites) {
        ctx.fillStyle = 'rgba(255, 184, 108, 0.95)';
        for (const p of state.points) {
          ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI * 2); ctx.fill();
        }
      }

      ctx.restore();
    }

    // Lloyd relaxation
    function lloyd(iterations) {
      const { cssWidth, cssHeight } = fitCanvas();
      for (let it = 0; it < iterations; it++) {
        const c = compute(cssWidth, cssHeight);
        if (!c) return;
        const { voronoi } = c;
        const next = [];
        for (let i = 0; i < state.points.length; i++) {
          const cell = voronoi.cellPolygon(i);
          if (!cell) { next.push(state.points[i]); continue; }
          const centroid = centroidOfPolygon(cell);
          if (!centroid) { next.push(state.points[i]); continue; }
          next.push(centroid);
        }
        state.points = next;
      }
      draw();
    }

    // Interaction
    const pointer = { x: 0, y: 0 };
    let draggingIndex = -1;
    let dragOffset = { x: 0, y: 0 };

    function eventToCanvasPoint(ev) {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      return { x: (ev.clientX - rect.left) * dpr / dpr, y: (ev.clientY - rect.top) * dpr / dpr };
    }
    function findNearestIndex(p, maxDist = 10) {
      let idx = -1, best = maxDist * maxDist;
      for (let i = 0; i < state.points.length; i++) {
        const dx = state.points[i].x - p.x;
        const dy = state.points[i].y - p.y;
        const d2 = dx * dx + dy * dy;
        if (d2 < best) { best = d2; idx = i; }
      }
      return idx;
    }

    canvas.addEventListener('pointerdown', (ev) => {
      const p = eventToCanvasPoint(ev);
      pointer.x = p.x; pointer.y = p.y;
      const hit = findNearestIndex(p, 10);
      if (ev.shiftKey) {
        if (hit !== -1) { saveHistory(); state.points.splice(hit, 1); draw(); }
        return;
      }
      if (hit !== -1) {
        draggingIndex = hit;
        dragOffset.x = state.points[hit].x - p.x;
        dragOffset.y = state.points[hit].y - p.y;
      } else {
        saveHistory();
        state.points.push({ x: p.x, y: p.y });
        draw();
      }
    });
    canvas.addEventListener('pointermove', (ev) => {
      if (draggingIndex === -1) return;
      const p = eventToCanvasPoint(ev);
      state.points[draggingIndex] = { x: p.x + dragOffset.x, y: p.y + dragOffset.y };
      draw();
    });
    canvas.addEventListener('pointerup', () => { draggingIndex = -1; });
    canvas.addEventListener('pointerleave', () => { draggingIndex = -1; });

    // Keyboard
    window.addEventListener('keydown', (ev) => {
      if ((ev.metaKey || ev.ctrlKey) && ev.key.toLowerCase() === 'z') {
        ev.shiftKey ? redo() : undo();
      }
    });

    // Controls
    function $(id) { return document.getElementById(id); }
    $('btn-random').addEventListener('click', () => {
      const n = Math.max(1, Math.min(5000, Number($('num-random').value) || 100));
      saveHistory();
      const { cssWidth, cssHeight } = fitCanvas();
      state.points.push(...jitterPoints(randomPoints(n, cssWidth, cssHeight), Number($('jitter').value || 0)));
      draw();
    });
    $('btn-clear').addEventListener('click', () => { saveHistory(); state.points = []; draw(); });
    $('btn-grid').addEventListener('click', () => {
      saveHistory();
      const { cssWidth, cssHeight } = fitCanvas();
      state.points = gridPoints(10, 7, cssWidth, cssHeight);
      draw();
    });
    $('btn-hex').addEventListener('click', () => {
      saveHistory();
      const { cssWidth, cssHeight } = fitCanvas();
      state.points = hexPoints(12, 8, cssWidth, cssHeight);
      draw();
    });
    $('btn-undo').addEventListener('click', undo);
    $('btn-redo').addEventListener('click', redo);

    $('btn-relax').addEventListener('click', () => {
      const it = Math.max(1, Math.min(50, Number($('relax-iters').value) || 1));
      saveHistory();
      lloyd(it);
    });

    $('jitter').addEventListener('input', () => {
      $('jitter-val').textContent = String($('jitter').value);
    });

    $('show-cells').addEventListener('change', (e) => { state.showCells = e.target.checked; draw(); });
    $('show-edges').addEventListener('change', (e) => { state.showEdges = e.target.checked; draw(); });
    $('show-sites').addEventListener('change', (e) => { state.showSites = e.target.checked; draw(); });
    $('show-delaunay').addEventListener('change', (e) => { state.showDelaunay = e.target.checked; draw(); });
    $('fill-mode').addEventListener('change', (e) => { state.fillMode = e.target.value; draw(); });

    // Export / Import
    $('btn-export').addEventListener('click', () => {
      const data = JSON.stringify({ points: state.points }, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'voronoi-points.json'; a.click();
      URL.revokeObjectURL(url);
    });
    $('file-import').addEventListener('change', (ev) => {
      const file = ev.target.files && ev.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const obj = JSON.parse(String(reader.result || '{}'));
          if (Array.isArray(obj.points)) {
            saveHistory();
            state.points = obj.points.map(p => ({ x: Number(p.x), y: Number(p.y) })).filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));
            draw();
          }
        } catch (e) { console.error(e); }
      };
      reader.readAsText(file);
      ev.target.value = '';
    });
    $('btn-copy-url').addEventListener('click', async () => {
      const params = new URLSearchParams();
      params.set('pts', btoa(unescape(encodeURIComponent(JSON.stringify(state.points)))));
      const share = location.origin + location.pathname + '?' + params.toString();
      try { await navigator.clipboard.writeText(share); } catch {}
    });

    // Load from URL
    (function loadFromURL() {
      const sp = new URLSearchParams(location.search);
      const enc = sp.get('pts');
      if (!enc) return;
      try {
        const json = decodeURIComponent(escape(atob(enc)));
        const arr = JSON.parse(json);
        if (Array.isArray(arr)) state.points = arr;
      } catch {}
    })();

    // Resize
    const resizeObserver = new ResizeObserver(() => draw());
    resizeObserver.observe(document.querySelector('.canvas-wrap'));
    window.addEventListener('orientationchange', draw);

    // Initial seed
    (function seed() {
      if (state.points.length) { draw(); return; }
      const { cssWidth, cssHeight } = fitCanvas();
      state.points = randomPoints(50, cssWidth, cssHeight);
      draw();
    })();
  </script>
</body>
</html>


